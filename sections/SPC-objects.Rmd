
## The SoilProfileCollection Object

  <!-- * rationale -->
  <!-- * basic design / strategy -->
  <!-- * various back-ends -->
  <!-- * limitation (analysis vs. archival formats) -->

The `SoilProfileCollection` (SPC) is a data structure designed to coordinate linkages between elements within the typically complex (hierarchical) site description, soil morphologic description, and optionally laboratory data. Methods (data structure-specific functions) operating on the SPC include special constraints to ensure linkages aren't broken during routing operations such as editing, sub-setting, or combining collections. The first level of abstraction involves two main tiers: "site" for above-ground or those properties that are specific to a single soil profile description (e.g. surface slope), and "horizon" for below-ground or those properties that are specific to a single genetic soil horizon or layer. An additional level of abstraction is used to store spatial data (coordinates and coordinate reference system) and depth-intervals information such as diagnostic horizons. The SPC also provides a means of storing user-defined metadata such as units of measure, column containing horizon designation, data source, and data citation to name a few.

Of primary importance are the horizon data, or the layers that comprise the profiles in the collection. The `SoilProfileCollection` is "horizon data forward," in that you start with a table of horizon data: each record must have an upper and lower boundary, a unique ID linking to a single soil profile observation, and any other observed or measured properties. There are no set limits on the number of horizons per profile, or profiles per collection, but, available memory will dictate practical limitations. Horizon depths should be specified as integers (typically centimeters) and should not overlap.

A `SoilProfileCollection` is created through "promotion" of an **R** `data.frame` (or `data.frame`-like object such as `tibble` or `data.table`) with the `depths()` function. This process requires the following parameters: `profile_id` (the name of a column containing unique profile IDs), `top_depth` (the name of a column containing horizon upper depths) and `bottom_depth` (the name of a column containing horizon lower depths) along with any additional horizon data associated with the horizons in the profile. For example, the promotion of a `data.frame` called `x` to `SoilProfileCollection` would like something like: `depths(x) <- profile_id ~ top_depth + bottom_depth`.

In **R**, the symbol `~` separates the left and right hand sides of a formula. Commonly `~` is used in formulas to mean "modeled as". In the case of the `SoilProfileCollection` we are "modeling" the geometry and ordering of horizons within each unique profile using the upper and lower depths. Performing this operation automatically sorts horizon data first by profile ID and then by horizons top depth. 

Additional site and horizon data can be added or extracted one by one using the `$` or `[[` methods. If you are creating a new variable, the `SoilProfileCollection` will check whether the length of the vector matches either the number of "sites" or the number of "horizons". 



If you have many columns to add to site or horizon data, you may be better off using the "join" syntax.

In this case, the value on the right hand side of the assignment operator `<-` is a data.frame that contains at least one column name and value in common with the target table, which is specified on the left hand side using `site(object)` or `horizons(object)`. 


<!-- ```{r} -->
<!-- # add two columns to the site and horizon data using left join. -->
<!-- site(object) <- data.frame(profile_id = 1, treatment = LETTERS[1], field = 2) -->
<!-- horizons(object) <- data.frame(hzID = 2, hz_note = "Note for Horizon #2", note_author = "AGB") -->
<!-- ``` -->


The right hand side table is then merged into the data slots of `object`. Join fields that aren't matched will be filled with `NA`. If ID values are present in the right hand side that don't exist in the left, or the join would duplicate existing rows in the collection, the merge will stop with an error.

[@SPC_intro]


### Subsetting

  
#### "bracket" extraction methods (`x[i,j,k...]`)

One of the primary approaches to subsetting a `SoilProfileCollection` uses the "bracket" `[` methods to extract smaller collections from a larger collection based on numeric or logical indices. The syntax is similar to extracting rows and columns from matrix or data.frame objects in base R. 

If `x` is a `SoilProfileCollection` then the syntax for the bracket methods is: `x[i, j, k...]`; where `i` is a profile index, `j` is a within-profile horizon index and `k...` represents optional special functions that can operate on the horizon data in the collection to replace the profile-specific `j`-index.

To obtain the first profile in the collection, you can use the syntax `x[1, ]`. For the first horizon in each profile you can use `x[, 1]`. To get the last horizon of each profile, you can use `x[, , .LAST]` where `.LAST` is a special "keyword" that can identify the `j`-index of the deepest horizon in each profile. 

Subsets based on `i`, `j` and `k` indices of the `SoilProfileCollection` can be combined, for instance: `x[1:2, 1:2]` gives the first two horizons of the first two profiles. Also, the `k` index can be combined with the `i` index, for instance `x[1:2, , .LAST]` gives the last horizon of the first two profiles.

Here is a visual representation of the concept:

```{r SPC-subsetting-figure-1, echo = FALSE, fig.width=9.5, fig.height=5, fig.cap=""}
library(aqp)

# hack
.LAST <- NULL
.FIRST <- NULL

# this is an example two-pane figure where a small subset of profiles is shown based on i index
# then one profile gets "zoomed in on" and the different [ horizon extraction methods are demonstrated
x <- readRDS("../local-data/clarksville-all-pedons.rds")

# keep first 5 profiles, kind = series
x <- subset(x, taxonkind == 'series')[1:5, ]

# new ID for simpler explanation
site(x)$newID <- sprintf("Profile %s", 1:5)

# remove O horizon labels for clarity
x$hzname[grep('O', x$hzname)] <- NA

# default color for O horizons
.col <- parseMunsell('10YR 2/2')

# 
par(mar=c(0,0,0,0), mfrow=c(1,2))

# figure of first five profiles
set.seed(101010)
plotSPC(x, cex.names = 0.7, label = 'newID', max.depth = 225, width = 0.25, default.color = .col, plot.depth.axis = FALSE, name.style = 'center-center', hz.depths = TRUE, fixLabelCollisions = TRUE, hz.depths.offset = 0.05, font.id = 1)

# label subfigure
mtext(text = 'A) Original Data', side = 1, line = - 2, font = 2)

# example to subset
idx <- 5

# SPCs to plot
.s <- list(
  x[idx, ], 
  x[idx, 1], 
  x[idx, 3:6], 
  x[idx, , .FIRST],
  x[idx, , .LAST]
)


# using the same set of arguments for each iteration
.arg1 <- list(color = "soil_color", label = 'newID', max.depth = 225, cex.names = 0.7, width = 0.25, name.style = 'center-center', hz.depths = TRUE, fixLabelCollisions = TRUE, hz.depths.offset = 0.05, font.id = 1)

# dumb trick to replicate a list
.a <- list(.arg1)[rep(1, times = 5)]

# labels
.labs <- c(
  sprintf("x[%s, ]", idx), 
  sprintf("x[%s, 1]", idx), 
  sprintf("x[%s, 3:6]", idx), 
  sprintf("x[%s, , .FIRST]", idx),
  sprintf("x[%s, , .LAST]", idx)
)


plotMultipleSPC(
  .s, 
  args = .a,
  plot.depth.axis = FALSE,
  group.labels = .labs,
  label.offset = 20,
  label.cex = 0.75
)

mtext(text = 'B) Subsets of Profile 5', side = 1, line = - 2, font = 2)

```

The representation of horizon position with the `j`-index can be extended to develop other "horizon spatial predicates" such as `hzAbove()`, `hzBelow()` and `hzOffset()`. The former two take logical expressions to match horizons, and return the part of the collection adjacent to the match (above or below respectively). `hzOffset()` allows arbitrary horizon indices and offsets to be calculated. This type of logic is further helpful for inspecting and fixing horizon geometry for errors or inconsistencies.

  * `subset()` and NSE (Andrew)

Often we do not know which indices of profiles or horizons in our collection meet criteria of interest. We can use the aqp functions `subset()` and `subsetHz()` to use logical expressions in terms of the site or horizon variables to specify the constraints. These expressions make use of site or horizon-level variables in the collection. `subset()` returns whole profiles; if criteria were specified for horizon data then only some of the horizons of those profiles may meet criteria. `subsetHz()` requires horizon-level expressions and returns only the portion of horizons within profiles that meet criteria.

  * `glom()`, `trunc()` and related (Andrew) 

Partitioning data based on logical expressions of site and horizon level properties is powerful, but in soil science we often want to be able to extract data for specific ranges of depths. Two methods: `glom(x, z1, z2, ...)` and `trunc(x, z1, z2, ...)` facilitate this in aqp. `glom()` returns the subset of horizons in a collection that fall within a specific depth interval `[z1, z2]`. The depth interval could be a point or a range (`z2` optional). 

The interval `[z1, z2]` can be constant across the collection or unique to each profile. By default the whole horizon is returned unmodified whether it falls fully within the range or not--creating a "ragged" `SoilProfileCollection`. When `glom(truncate=TRUE)` or `trunc()` the upper and lower boundaries of the resulting horizons will be cut to the interval specified and the profiles will generally have consistent upper and lower boundaries assuming there are no missing data in the interval.

```{r SPC-subsetting-figure-2, echo = FALSE, fig.width=8, fig.height=4.5, fig.cap=""}
par(mar=c(0,0,0,1), mfrow=c(1,1))

.top <- 35
.bottom <- 95
idx <- 5

.s <- list(
  x[idx, ], 
  glom(x[idx, ], .top, .bottom), 
  trunc(x[idx, ], .top, .bottom)
)

# all the same
.arg1 <- list(label = 'newID', max.depth = 225, cex.names = 0.75, name.style = 'center-center', width = 0.2)

# dumb trick to replicate a list
.a <- list(.arg1)[rep(1, times = 3)]

.labs <- c(
  sprintf("x[%s, ]", idx), 
  sprintf("glom(x[%s, ], %s, %s)", idx, .top, .bottom), 
  sprintf("trunc(x[%s, ], %s, %s)", idx, .top, .bottom)
)

plotMultipleSPC(
  .s,
  args = .a,
  group.labels = .labs, 
  axis.line.offset = -3,
  label.offset = 10, 
  label.cex = 1
)

segments(x0 = 0.66, y0 = .top, x1 = 3.33, y1 = .top, lwd = 2, lty = 2)
segments(x0 = 0.66, y0 = .bottom, x1 = 3.33, y1 = .bottom, lwd = 2, lty = 2)
```


### Iteration

aqp provides utilities for iterating (looping) over the profiles in a `SoilProfileCollection.` Following the precedent of the base R `*apply()` functions, `profileApply()` will apply a function to each element of a `SoilProfileCollection.` 

The results of running the function on each profile are usually a single value per profile or horizon, with default `simplify=TRUE` converting them back to simplest vector representation. Alternately, the result can be one or more rows of a data.frame with `frameify = TRUE` to automatically create a data.frame with the results, or even a list containing more complex objects (such as `SoilProfileCollections` that can then be recombined with `aqp::combine()`).

### Sources of `SoilProfileCollection` Objects

The soilDB package for R provides a common interface to many of the National Cooperative Soil Survey databases. Several functions from this package return data as a `SoilProfileCollection` object: `fetchKSSL()` (laboratory characterization data), `fetchOSD()` (basic soil morphology from the Official Series Description), `fetchSDA()` (SSURGO and STATSGO data from Soil Data Access), and `fetchNASIS` (National Soil Information System).

### Data Quality and Repairs

aqp provides several methods for identifying problematic profile geometry and (possibly) "fixing" it. Most soil databases and methods for storing soils information do not have front end validations that entirely prevent entry of data with "illogical" content. Some analyses rely on having only one record of data per depth*profile combination such as those involving depth-weighted averages, or rely on having a "complete" set of records in all profiles over a particular interval.

`checkHzDepthLogic()` inspects a `SoilProfileCollection` object looking for four common errors in horizon depths: bottom depth shallower than top depth, equal top and bottom depth, missing (`NA`) top or bottom depth, and gap or overlap between adjacent horizons. With `byhz = TRUE` you can perform the first three of the above logic checks on individual horizons. 

`repairMissingHzDepths()` uses assumptions about horizon order based on horizon top depth. This can be used to fill in some missing (bottom) horizon depths. This function will set missing bottom depths of a horizon to the next deepest (adjacent) top depth. Also, it adds a constant vertical offset to the top depth of bottom-most horizons missing bottom depth. 

`fillHzGaps()` attempts to find "gaps" in the horizon records of a `SoilProfileCollection` object and fill with placeholder horizons (profile ID, horizon ID, to/bottom depths, all else NA). This function also allows you to fill profiles to a static top and bottom depth: for instance for lab data that includes an unsampled O horizons or variable depth to bedrock/bottom depth of bedrock. 


